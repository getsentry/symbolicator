{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Symbolicator is a standalone service that resolves function names, file location and source context in native and JavaScript stack traces. It can process minidumps, Apple crash reports and source maps. Additionally, Symbolicator can act as a proxy to symbol servers supporting multiple formats, such as Microsoft's symbol server or Breakpad symbol repositories.</p>"},{"location":"#usage","title":"Usage","text":"<p>Start the server with:</p> <pre><code>$ symbolicator run -c config.yml\n</code></pre> <p>The configuration file can be omitted. Symbolicator will run with default settings in this case.</p>"},{"location":"#configuration","title":"Configuration","text":"<p>Write this to a file (<code>config.yml</code>):</p> <pre><code>cache_dir: \"/tmp/symbolicator\"\nbind: \"0.0.0.0:3021\"\nlogging:\n  level: \"info\"\n  format: \"pretty\"\n  enable_backtraces: true\nmetrics:\n  statsd: \"127.0.0.1:8125\"\n  prefix: \"symbolicator\"\n</code></pre> <ul> <li><code>cache_dir</code>: Path to a directory to cache downloaded files and symbolication   caches. Defaults to <code>/data</code> inside Docker which is already defined as a   persistent volume, and <code>null</code> otherwise, which disables caching. It is   strictly recommended to configure caches in production!</li> <li><code>bind</code>: Host and port for HTTP interface.</li> <li><code>bind_https</code>: Host and port for optional HTTPS interface.<ul> <li>HTTPS support is a Cargo feature, and needs to be enabled during building:   <code>shell   cargo build --features https &lt;other build options&gt;</code></li> <li>Additionally for HTTPS support, paths to TLS certificate and key files need to be specified in the configuration file:<ul> <li><code>server_config</code>: web server configuration needed for serving over HTTPS.<ul> <li><code>https</code>: HTTPS configuration.<ul> <li><code>certificate_path</code>: Path to a TLS certificate file in PEM format.</li> <li><code>key_path</code>: Path to a TLS key file in PEM format.</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li><code>logging</code>: Command line logging behavior.<ul> <li><code>level</code>: Log level, defaults to <code>info</code>. Can be one of <code>off</code>, <code>error</code>,   <code>warn</code>, <code>info</code>, <code>debug</code>, or <code>trace</code>.</li> <li><code>format</code>: The format with which to print logs. Defaults to <code>auto</code>. Can be   one of: <code>json</code>, <code>simplified</code>, <code>pretty</code>, or <code>auto</code> (pretty on console,   simplified on tty).</li> <li><code>enable_backtraces</code>: Whether backtraces for errors should be computed. This   causes a slight performance hit but improves debuggability. Defaults to   <code>true</code>.</li> </ul> </li> <li><code>metrics</code>: Configure a statsd server to send metrics to.<ul> <li><code>statsd</code>: The host and port to send metrics to. Defaults to STATSD_SERVER   environment variable or in case it is not defined, then it defaults to <code>null</code>,   which disables metric submission.</li> <li><code>prefix</code>: A prefix for every metric, defaults to <code>symbolicator</code>.</li> <li><code>hostname_tag</code>: If set, report the current hostname under the given tag name for all metrics.</li> <li><code>environment_tag</code>: If set, report the current environment under the given tag name for all metrics.</li> </ul> </li> <li><code>sentry_dsn</code>: DSN to a Sentry project for internal error reporting. Defaults   to <code>null</code>, which disables reporting to Sentry.</li> <li><code>sources</code>: An optional list of preconfigured sources. If these are configured   they will be used as default sources for symbolication requests and they will   be proxied by the symbol proxy if enabled. The format for the sources here   matches the sources in the HTTP API.</li> <li><code>symstore_proxy</code>: Enables or disables the symstore proxy mode. Creates an   endpoint to download raw symbols from configured sources Symbolicator as if it   were a <code>symstore</code> (Microsoft Symbol Server) compatible server. Defaults to   <code>true</code>.</li> <li><code>connect_to_reserved_ips</code>: Allow reserved IP addresses for requests to   sources. See Security. Defaults to <code>false</code>.</li> <li><code>traces_sample_rate</code>: The sample rate for traces sent to Sentry. Should be a value between <code>0.0</code> and <code>1.0</code>. Defaults to <code>0.05</code>.</li> <li><code>propagate_traces</code>: When tracing is enabled, inherit the sample rate from incoming parent traces and if Sentry is used as a symbol source also propagate traces back to Sentry. Defaults to <code>true</code>.</li> <li><code>max_concurrent_requests</code>: The maximum number of requests symbolicator will process concurrently. Further requests will result in a 503 status code.   Set it to <code>null</code> to turn off the limit. Defaults to 120.</li> </ul> <p>All time units for the following configuration settings can be either a time expression like <code>1s</code>.  Units can be <code>s</code>, <code>seconds</code>, <code>m</code>, <code>minutes</code>, <code>h</code>, <code>hours</code>, <code>d</code>, <code>days</code>, <code>w</code>, <code>weeks</code>, <code>M</code>, <code>months</code>, <code>y</code>, <code>years</code>.</p> <ul> <li><code>max_download_timeout</code>: The timeout for downloading debug files.</li> <li><code>connect_timeout</code>: The timeout for establishing a connection to a symbol   server to download debug files.</li> <li><code>streaming_timeout</code>: The timeout for streaming the contents of a debug file.</li> <li><code>caches</code>: Fine-tune cache expiry.</li> </ul> <p>Time units for caches may also be <code>null</code> to disable cache expiration.</p> <ul> <li><code>downloaded</code>: Fine-tune caches for downloaded files.<ul> <li><code>max_unused_for</code>: Maximum duration to keep a file since last   use of it.</li> <li><code>retry_misses_after</code>: Duration to wait before re-trying to   download a file which was not found.</li> <li><code>retry_malformed_after</code>: Duration to wait before re-trying to   download a file which was malformed.</li> <li><code>max_lazy_redownloads</code>: Symbolicator will fall back to a compatible but out-of-date cache version if available,   and start computing the up-to-date version in the background. This option sets the maximum number of such lazy downloads that symbolicator will do concurrently. Defaults to 50.</li> </ul> </li> <li><code>derived</code>: Fine-tune caches for files which are derived from   downloaded files.  These files are usually versions of the   downloaded files optimised for fast lookups.<ul> <li><code>max_unused_for</code>: Maximum duration to keep a file since last   use of it.</li> <li><code>retry_misses_after</code>: Duration to wait before re-trying to   download a file which was not found.</li> <li><code>retry_malformed_after</code>: Duration to wait before re-trying to   download a file which was malformed.</li> <li><code>max_lazy_recomputations</code>: Symbolicator will fall back to a compatible but out-of-date cache version if available,   and start computing the up-to-date version in the background. This option sets the maximum number of such lazy computations that symbolicator will do concurrently. Defaults to 20.</li> </ul> </li> <li><code>diagnostics</code>: This configures the duration diagnostics data   will be stored in cache.  E.g. minidumps which failed to be   processed correctly will be stored in this cache.<ul> <li><code>retention</code>: Duration a file will be kept in this cache.</li> </ul> </li> </ul>"},{"location":"#security","title":"Security","text":"<p>By default, Symbolicator does not try to download debug files from reserved IP ranges. This ensures that no unintended connections are made to internal systems when source configuration is passed in from an untrusted source.</p> <p>To allow internal connections, set <code>connect_to_reserved_ips</code> to <code>true</code>.</p> <p>An exception from this rule is the <code>\"sentry\"</code> source type. Sentry is expected to run within the same network as Symbolicator, which is why it is exempt by default.</p>"},{"location":"advanced/background-and-principles/","title":"Background and Principles","text":"<p>This page describes reasoning behind the design of Symbolicator.</p>"},{"location":"advanced/background-and-principles/#symbolicator-principles","title":"Symbolicator Principles","text":"<p>Symbolicator is a service that unifies symbolication for all kinds of native frames and allows us to add more features or improve performance more easily than in the former setup. Goals of Symbolicator are:</p> <ul> <li>Symbolicate entire stack traces at once, referencing both system and   customer images. Thanks to this, heuristics for detecting system images are no   longer necessary.</li> <li>Fetch DIFs from external sources. These could be third-party servers like   the online Microsoft Symbol Server or buckets of DIFs hosted by our customers.   This removes the need to proactively upload files to Sentry that will never be   used.</li> <li>Treat SymCaches and Debug Files as transient. All files are put in a local   file system cache for faster access, but there is no persistent storage for   symcaches or files retrieved from an external resources. This also simplifies   upgrades (simply wipe the cache).</li> <li>Avoid one-hit wonders. SymCaches only need to be generated for debug files   that are hit multiple times within a time frame. For all other symbols, using   the original debug file is sufficiently fast \u2014 especially since it only needs   to be loaded once per symbolication request.</li> <li>Improve processing of minidumps. Potentially use multiple debug files or   cache files at once to run stackwalking and symbolication in a single run.   This reduces resource allocation and gets rid of our hacks in the breakpad   processor.</li> </ul>"},{"location":"advanced/background-and-principles/#issues-symbolicator-solves","title":"Issues Symbolicator Solves","text":"<p>Symbolicator was developed at [Sentry] to allow for faster iteration speeds and improve symboilcation performance. There were a couple of general issues with native event processing:</p> <ul> <li>Matching of system symbol paths sometimes yields false positives</li> <li>SymbolServer only handles iOS system symbols and cannot resolve line numbers</li> <li>Handling of DIFs in Sentry causes a lot of overhead in the blob storage and is   prone to race conditions</li> <li>Customers are starting to hit the maximum file size limit of 2GB</li> <li>DIFs always need to be uploaded before events, whether they are used or not</li> <li>Minidump processing requires multiple debug files at once, which required   hacks in Sentry.</li> </ul> <p>Additionally, there were issues around the upload of debug information files.</p> <ol> <li>SymCaches and CFI caches are computed ahead of time and persisted. This    creates inherent race conditions and also requires computation, even if the    symbols are never used.</li> <li>Debug file models only store the debug identifier. This works for Breakpad    minidumps and custom SDKs, but will never be compatible to native debuggers    or other systems.</li> <li>The old logic for choosing files based on debug ids is based on the upload    time. This was done to reduce the amount of fetching from the file storage    onto workers. However, this might choose a suboptimal file.</li> <li>During symbol upload, older \"redundant\" files are deleted. A file is    considered redundant, if it only provides a subset of the features of all    newer files combined. Since this does not consider the file type, this might    throw away better debug information in favor of a newer, worse file (e.g.    when a breakpad file is uploaded after the original debug file).</li> </ol>"},{"location":"advanced/background-and-principles/#terminology","title":"Terminology","text":""},{"location":"advanced/background-and-principles/#debug-information-files","title":"Debug Information Files","text":"<p>DIFs contain \"debug information\" to resolve function names and file locations from raw memory addresses in native crash reports. These files can get quite large, and we have encountered first customers with files over 2GB.</p> <p>Additionally, DIFs come in various different formats depending on the operating system and build process. In some scenarios, a combination of multiple files might be needed to successfully symbolicate a native crash. This has first been encountered in minidumps, which require the executable to extract stack traces, but a separate debug file to symbolicate its addresses.</p> <p>To mitigate issues with file size and platform differences, we created SymCaches. These are custom binary files that store an essential subset of the original debug information in a uniform format. The file format is optimized for direct mapping into memory and fast lookups of addresses. SymCaches are created for every DIF uploaded by customers that contains valid debug information.</p>"},{"location":"advanced/caching/","title":"Caching","text":"<p>Conceptionally, Symbolicator does not store debug information files but treats them as transient caches. Symbolicator caches two types of files: Raw debug information files and symbolication caches.</p>"},{"location":"advanced/caching/#cache-files","title":"Cache Files","text":"<p>Symbolicator caches two kinds of files: original Debug Information Files and derived caches which comprise SymCaches and CFI caches.</p> <ul> <li>Debug Information Files (Object Files) (original): The original debug   files as they are stored on external sources. They are cached to allow for   faster recomputation of the derived caches, especially when after an update   the format of the derived caches change. Otherwise, all original files would   have to be downloaded again which could incur significant performance impact.   DIFs are platform dependent and usually large in size, up to multiple GB.   Their internal structure is platform dependent.</li> <li>Object Meta Files (derived): Important attributes of a Object File used to   determine which Object File is the best one. This information is persisted   separately from Object Files because we want to delete Object Files a few days   after download for disk we want to delete Object Files a few days after   download for disk space while still knowing some information about them.</li> <li>Symbolication Caches (derived): A platform-independent representation of   function and line information to symbolicate instruction addresses. Those   files are usually significantly smaller than native DIFs. However, endianness   of the file contents depends on the host so these files cannot be transferred   between systems with different endianness.</li> <li>CFI Caches (derived): A platform-independent representation of stack   unwind information to allow stackwalking. This currently uses the Breakpad   ASCII format.</li> </ul>"},{"location":"advanced/caching/#cache-rules","title":"Cache Rules","text":"<p>In addition to caching DIFs and derived caches, Symbolicator also stores placeholders to indicate the absence of or errors when retrieving or computing those files. The cache adheres to the following rules:</p> <ol> <li>DIFs are cached until they have not been used for 7 days but may be deleted    earlier when disk space is running out. A DIF is used when a derived cache is    computed from it.</li> <li>Derived caches that were successfully created from preferred DIFs are cached    until they have not been used for at least 7 days.</li> <li>Derived caches that were successfully created from fallback DIFs are treated    equally but at most once per hour an upgrade attempt is started to search    for better DIFs.</li> <li>The absence of a DIF is cached for 1 hour, after that another fetch attempt    from all sources is started.</li> <li>Failed conversions (due to malformed or unsupported debug files) are cached    for 24 hours but only up to the next restart. After that, another    conversion is attempted. The restart constraint serves the purpose to allow    immediate bug fixes.</li> </ol> <p>Derived caches can continue to be stored independently of the DIFs they were created from. Because they are smaller than the originals, this contributes to a better use of the available disk space. All timeouts mentioned above are configurable:</p> <pre><code>caches:\n  downloaded:\n    max_unused_for: 7d # unused DIFs, rule 1\n    retry_misses_after: 1h # absence of a DIF, rule 4\n  derived:\n    max_unused_for: 7d # unused caches, rule 2\n    retry_misses_after: 1h # also necessary for rule 4\n</code></pre>"},{"location":"advanced/caching/#cache-enforcement","title":"Cache Enforcement","text":"<p>In order to enforce the desired cache behavior, Symbolicator uses file system meta data and information stored in the files themselves to determine when to evict items from the cache.</p> <ol> <li>Last use of derived cache: The time when a derived cache was last used in    a symbolication request. This allows to prune cold caches from the system,    even from an external service. This value is stored in the mtime of the    symbolication file and updated at most once per hour.</li> <li>Last attempt to fetch dependencies of a cache: The time when the a    derived cache could not be constructed because no debug files were available.    Instead, a placeholder cache file is created and its mtime indicates the    attempt. If this file is older than the threshold (default 1 hour), another    fetch attempt can be started and the file is recreated or replaced. NOTE:    The placeholder is created for the derived cache only, because otherwise too    many placeholders would be created.</li> <li>Last failed cache conversion: The time when deriving a cache from a    native DIF failed due to an error. A placeholder file is created and its    mtime indicates the attempt. If a file is older than the threshold (default    24 hours), conversion is repeated. If the debug files have been deleted in    between, this causes another fetch from external sources.</li> <li>DIFs used for derived cache: The kind of debug information that was used    to compute a derived cache. SymCaches store this in their header, so this can    be retrieved inexpensively by opening the file. CFI caches currently do not    contain this information, although all DIFs offer equal quality of unwind    information.</li> <li>Last cache upgrade: The last time when an upgrade of an existing derived    cache was attempted since it was not computed from a preferred source. This    also uses the file\u2019s mtime and attempts an update every time the    modification time exceeds the threshold.</li> </ol>"},{"location":"advanced/caching/#scopes","title":"Scopes","text":"<p>Cached files are associated to a scope, which is given by the symbolication request. The default is a \u201cglobal\u201d scope, which implicitly makes the files accessible to any request (scoped and not scoped). Otherwise, the scope needs to match for caches to be used. Note that there is no verification of the scope number, so users of Symbolicator are required to ensure the soundness of scope values.</p> <p>Scoping is achieved by encoding the scope identifier into the cache paths, thus creating separate cache directories for each scope.</p>"},{"location":"advanced/caching/#pruning-caches","title":"Pruning Caches","text":"<p>The <code>symbolicator cleanup</code> command removes stale caches. This command needs to be run manually and periodically, or at least when disk space is about to run out.</p> <p>Symbolicator operates under the assumption that files may be removed by an external actor at any time (one such actor is <code>symbolicator cleanup</code> itself which does not really attempt to synchronize with the main symbolicator service).</p> <p>Symbolicator assumes a fully POSIX-compliant filesystem to be able to serve requests without interruptions while files are being deleted. Using a network share for the cache folder will not work.</p>"},{"location":"advanced/shared-cache/","title":"Shared Cache","text":"<p>When running multiple symbolicators each instance has its own local cache.  Starting up a new symbolicator instance in such an environment means it will have a cold cache and take a long time before it can process events at the same rate.  To remedy this symbolicators can be configured to share their caches.</p> <p>When configured like this all caches will be shared, both original files and derived caches, thus a new symbolicator will not need to do all the computation to create missing common derived caches.  However cache-computation is not coordinated, so if new caches are needed the shared cache works on a first-write-wins principle as all caches are identical for a given cache key.</p>"},{"location":"advanced/shared-cache/#configuration","title":"Configuration","text":"<p>The shared cache is enabled by adding a new map in the config file:</p> <pre><code>shared_cache:\n  # The number of allowed concurrent uploads to the shared cache.\n  #\n  # Uploading to the shared cache is not critical for symbolicator's operation and\n  # should not disrupt any normal work it does.  This limits the number of concurrent\n  # uploads so that associated resources are kept in check.\n  max_concurrent_uploads: 20\n  # The number of queued up uploads to the cache.\n  #\n  # If more items need to be uploaded to the shared cache than there are allowed\n  # concurrently the uploads will be queued.  If the queue is full the uploads are\n  # simply dropped as they are not critical to symbolicator's operation and not\n  # disrupting symbolicator is more important than uploading to the shared cache.\n  max_upload_queue_size: 100\n\n  # In production only Google Cloud Service is supported.\n  gcs:\n    # Required\n    bucket: \"bucket-name\"\n    # Optional name to service account .json file\n    #\n    # If not used the GCP internal metadata service will be used to retrieve tokens.\n    service_account_path: \"/path/to/service-account.json\"\n\n  # For testing an alternative backend is supported, this **can not** be used\n  # at the same time as the `gcs` option.\n  filesystem:\n    path: \"/some/path/to/a/dir/\"\n</code></pre>"},{"location":"advanced/source-bundles/","title":"Source Bundles","text":"<p>Symbolicator supports the concept of source bundles.  These are zip archives containing source code that goes along debug information files.  These archives can be created with the <code>sentry-cli</code> tool as well as <code>symsorter</code> and are also supported by the underlying <code>symbolic</code> library.</p> <p>Source bundles are ZIP archives with a well-defined internal structure. Most importantly, they contain source files in a nested directory structure. Additionally, there is meta data associated to every source file, which allows to store additional properties, such as the original file system path, a web URL, and custom headers.</p>"},{"location":"advanced/source-bundles/#header","title":"Header","text":"<p>The source bundle is a regular ZIP archive but has a special header prepended to identify it uniquely as source bundle.</p> <p>The header is in little endian:</p> <pre><code>BUNDLE_MAGIC:    [u8; 4]\nBUNDLE_VERSION:  u32\n</code></pre> <p>The bundle magic is always ASCII \"SYSB\" (symbolic source bundle)</p>"},{"location":"advanced/source-bundles/#structure","title":"Structure","text":"<p>The internal structure is as follows:</p> <pre><code>manifest.json\nfiles/\n  file1.txt\n  subfolder/\n    file2.txt\n</code></pre>"},{"location":"advanced/source-bundles/#manifest","title":"Manifest","text":"<p>The manifest is a JSON file with the following structure:</p> <pre><code>{\n  \"files\": {\n    \"path/in/bundle\": {\n      \"type\": \"source\",\n      \"path\": \"original/file/name\",\n    }\n  },\n  \"code_id\": \"CODE_ID\",\n  \"debug_id\": \"DEBUG_ID\",\n  \"object_name\": \"OBJECT_NAME\",\n  \"arch\": \"ARCHITECTURE\"\n}\n</code></pre> <p>The attributes must match the attributes of the debug information file (.pdb, or DWARF file) that goes along with it.</p> <p>Example Manifest:</p> <pre><code>{\n  \"files\": {\n    \"files/actix-web-0.7.19/src/server/h1.rs\": {\n      \"type\":\"source\",\n      \"path\":\n      \"/usr/local/cargo/registry/src/github.com-1ecc6299db9ec823/actix-web-0.7.19/src/server/h1.rs\"\n    },\n    ...\n  },\n  \"arch\": \"x86_64\",\n  \"code_id\": \"f53af9062b83bc3b6dfd27a46912605f23e874de\",\n  \"debug_id\": \"06f93af5-832b-3bbc-6dfd-27a46912605f\",\n  \"object_name\": \"relay\"\n}\n</code></pre> <p>In this case the source file needs to be stored in the following location in the bundle: <code>files/actix-web-0.7.19/src/server/h1.rs</code>.</p>"},{"location":"advanced/symbol-lookup/","title":"Lookup Strategy","text":"<p>Symbolicator queries a list of external sources for debug information files which it uses to process minidumps and symbolicate stack traces. Based on availability, the CPU architecture and the operating system, it may determine the \"best\" file to use:</p> <ol> <li>Compute the code and debug identifiers for the modules to load.</li> <li>Look up available files in all sources</li> <li>Choose the best available file</li> </ol>"},{"location":"advanced/symbol-lookup/#identifiers","title":"Identifiers","text":"<p>Symbol servers use native identifiers to locate files. Usually, they put them in a directory hierarchy for easier retrieval.</p> <p>There are two kinds of identifiers:</p> <ul> <li>Code Id: Native identifier of the actual binary (library or executable).   Usually, this is a value stored in the header or computed from its contents.</li> <li>Debug Id: Identifier of the associated debug file on some platforms, or a   mangled version of the code identifier on other platforms.</li> </ul> <p>To look up different symbol kinds, the symbol server uses the following process to determine the ID (see below for exact conversion algorithms):</p> <ul> <li>MachO: Use the UUID which is stored interchangeably in <code>debug_id</code> and   <code>code_id</code>. If one of these values is missing, it can be computed from the   other. Primarily, the <code>code_id</code> should be used.</li> <li>ELF: Use the GNU build id which is given in the <code>code_id</code>. The <code>debug_id</code>   can be computed from this <code>code_id</code>, but not the other way around. Thus, if   the <code>code_id</code> is missing, lookups may not be possible.</li> <li>PE: Windows executables use a combination of timestamp and size fields to   compute a <code>code_id</code>. It is mandatory, as it cannot be derived from the   <code>debug_id</code>.</li> <li>PDB: Windows PDBs have their own <code>debug_id</code>, which can be read from the   PDB or PE header. It is mandatory, as it cannot be derived from the <code>code_id</code>.</li> <li>Portable PDB: Like PDBs, portable PDBs have their own <code>debug_id</code>.</li> <li>Breakpad: Google Breakpad uses <code>debug_id</code> for all symbol kinds. If it is   missing, it can be computed from the <code>code_id</code> if this is possible using the   above rules.</li> </ul>"},{"location":"advanced/symbol-lookup/#symbol-precedence","title":"Symbol Precedence","text":"<p>Depending on the desired information and type of image, the Symbolicator requests several files and chooses the best one. Note that the image type depends on the platform, but there are multiple formats for debug information files available.</p> <p>The following is a table of what we initially deemed as ideal lookup strategy. How we deviate from this in practice is documented separately.</p>"},{"location":"advanced/symbol-lookup/#symbol-table","title":"Symbol Table","text":"Platform 1. Choice 2. Choice 3. Choice MachO MachO (dSYM) MachO (code) Breakpad ELF ELF (debug) ELF (code) Breakpad PE PDB PE Breakpad"},{"location":"advanced/symbol-lookup/#debug-information","title":"Debug Information","text":"Platform 1. Choice 2. Choice 3. Choice MachO MachO (dSYM) Breakpad ELF ELF (debug) ELF (code) Breakpad PE PDB Breakpad .NET PE Portable PDB"},{"location":"advanced/symbol-lookup/#unwind-information","title":"Unwind Information","text":"Platform 1. Choice 2. Choice MachO MachO (code) Breakpad ELF ELF (code) Breakpad PE (32-bit) PDB Breakpad PE (64-bit) PE Breakpad"},{"location":"advanced/symbol-lookup/#implementation-notes","title":"Implementation Notes","text":"<ul> <li>Symbolicator downloads all filetypes in parallel and filters by whether   symbolic says that a file has debug/unwind information. There is no special   codepath for each table presented here, and especially not for each   platform/filetype.</li> </ul> <p>This creates a few more downloads than what would be necessary for a specific   task, but those should not matter considering that you e.g. will likely look   into debug information very soon if you already look for unwind information.</p> <ul> <li>As a result of the previous point, Symbolicator does not differentiate between   32-bit and 64-bit platforms, meaning that even on 64-bit Windows it will   attempt to look into the PDB to find relevant information. Again this should   not matter in terms of correctness as it will still also unconditionally look   into the PE and pick that if it's deemed to be be of better quality.</li> </ul>"},{"location":"advanced/symbol-lookup/#conversion-algorithms","title":"Conversion Algorithms","text":"<p>Some identifiers may be computed from others. See the following list for allowed non-lossy conversions in pseudocode:</p> <ul> <li> <p>MachO: <code>code_id</code> \u2190\u2192 <code>debug_id</code>. Symbolicator implements this by using the   code ID everywhere.</p> </li> <li> <p>ELF: <code>code_id</code> \u2192 <code>debug_id</code>. This is not yet implemented.</p> <pre><code>debug_id = code_id[0..16]\n\nif object.little_endian {\n  debug_id[0..4].reverse(); // uuid field 1\n  debug_id[4..6].reverse(); // uuid field 2\n  debug_id[6..8].reverse(); // uuid field 3\n}\n</code></pre> </li> </ul>"},{"location":"advanced/symbol-server-compatibility/","title":"Symbol Server Compatibility","text":"<p>This page describes external sources supported by Symbolicator.</p> <p>The layout of external sources intends to be compatible to several symbol server implementations that have been used historically by different platforms. We commit to provide compatibility to the following services or directory structures:</p> <ul> <li>Microsoft Symbol Server</li> <li>Breakpad Symbol Repositories</li> <li>LLDB File Mapped UUID Directories</li> <li>GDB Build ID Directories</li> <li>debuginfod</li> <li>Unified Symbol Server Layout</li> </ul>"},{"location":"advanced/symbol-server-compatibility/#lookup-types","title":"Lookup Types","text":"<p>Symbolicator uses different lookup types to support different servers which do not map 1:1 to a symbol server. The two most common lookup types are <code>native</code> and <code>unified</code>.</p>"},{"location":"advanced/symbol-server-compatibility/#native","title":"<code>native</code>","text":"<p>This lookup type emulates the most \"native\" symbol server format depending on the file type. This for instance means for PDB and PE files this turns into Microsoft Symbol Server. It also adds support for breakpad and will use LLDB/GDB formats for MachO and ELF respectively. This symbol server type also has support for source bundles for all file types.</p>"},{"location":"advanced/symbol-server-compatibility/#unified","title":"<code>unified</code>","text":"<p>This is the symbolicator proprietary but preferred source (Unified Symbol Server Layout) which adds a consistent lookup format for all architectures. It's used at Sentry for the internal symbol lookups (like Apple or Android symbols). Like The <code>native</code> format this supports source bundles.</p>"},{"location":"advanced/symbol-server-compatibility/#prerequisites","title":"Prerequisites","text":""},{"location":"advanced/symbol-server-compatibility/#identifiers","title":"Identifiers","text":"<p>There are two fundamentally different identifiers. Their semantics fundamentally depend on the symbol type, but follow certain rules:</p> <ul> <li>Code Identifier: Identifies the actual executable or library file (e.g.   EXE or DLL)</li> <li>Debug Identifier: Identifies a debug companion file (e.g. PDB)</li> </ul> <p>On all platforms other than Windows, binaries and debug companion files use the same file type and share the same container. The Breakpad library has thus changed the semantics of those identifiers for all other platforms to:</p> <ul> <li>Code Identifier: The original platform-specific identifier</li> <li>Debug Identifier: A potentially lossy transformation of the code   identifier into a unified format similar to the PDB debug identifiers.</li> </ul> <p>Specifically, the code and debug identifiers are defined as follows:</p> <p>ELF:</p> <ul> <li>Code ID: The contents of the <code>.note.gnu.build-id</code> section, or if not   present the value of the <code>NT_GNU_BUILD_ID</code> program header. This value is   traditionally 20 bytes formatted as hex string (40 characters). If neither   are present, there is no code id.</li> <li>Debug ID: The first 16 bytes of the GNU build id interpreted as   little-endian GUID. This flips the byte order of the first three components   in the build ID. An age of <code>0</code> is appended at the end. The remaining bytes   of the build ID are discarded. This identifier is only specified by   Breakpad, but by SSQP.</li> </ul> <p>MachO:</p> <ul> <li>Code ID: The UUID as specified in the <code>LC_UUID</code> load command header.   Breakpad does not save this value explicitly since it can be converted   bidirectionally from the UUID.</li> <li>Debug ID: The same UUID, amended by a <code>0</code> for age.</li> </ul> <p>WASM:</p> <ul> <li>Code ID: The bytes as specified in the <code>build_id</code> custom section.</li> <li>Debug ID: The same as code ID but truncated to 16 bytes + <code>0</code> for age.</li> </ul> <p>PE / PDB / Portable PDB:</p> <ul> <li>Code ID: The hex value of the <code>time_date_stamp</code> in the COFF header   formatted as <code>%08X</code> followed by <code>size_of_image</code> in the optional header   formatted as <code>%X</code> (variable length). This value is always read from the PE -   computing this from a PDB is not possible without locating the according PE.</li> <li>Debug ID: The <code>signature</code> and <code>age</code> (<code>%X</code> variable length) fields from   the debug information stream in the PDB. The fields in the signature GUID   are converted to network byte order first. This identifier can also be   computed from a PE by reading the <code>code_view_pdb_70</code> records.</li> </ul> <p>Breakpad:</p> <ul> <li>Code ID: If applicable, Breakpad symbols will contain a <code>INFO CODE_ID</code>   record in the second line. Otherwise, the code ID is equal to the Debug ID.</li> <li>Debug ID: Value of the identifier field in the <code>MODULE</code> record, always   in the first line of the file.</li> </ul> <p>Source Bundles:</p> <p>Symbolicator supports the concept of source bundles which are source archives which can be used to extract source code for crashes. These source bundles are an extension which are not available to all lookup types.</p>"},{"location":"advanced/symbol-server-compatibility/#case-sensitivity","title":"Case Sensitivity","text":"<p>Most symbol servers explicitly define case insensitive lookup semantics. This goes in particular for the Microsoft Public Symbol Server. However, the canonical representation on the file system is not necessarily case insensitive, for example when the files are stored on an Amazon S3 bucket. Since this is a hard restriction, the case for lookups is explicitly defined for each source below. Please pay attention to the casing rules!</p>"},{"location":"advanced/symbol-server-compatibility/#compression","title":"Compression","text":"<p>Symbolicator supports a range of compression formats (zlib, gzip, zstd and cab). For cab compression, the <code>cabextract</code> binary needs to be installed. If the debug file is already compressed, it will be auto-detected and extracted. For PE/PDB files, Symbolicator also supports the Microsoft convention of replacing the last character in the filename with an underscore.</p>"},{"location":"advanced/symbol-server-compatibility/#supported-servers","title":"Supported Servers","text":""},{"location":"advanced/symbol-server-compatibility/#breakpad","title":"Breakpad","text":"<p>Breakpad always computes a \"Breakpad ID\" for each symbol. This is a lossy process depending on the file type. Sentry stores a bidirectionally compatible version of this in the <code>debug_id</code> field.</p> <p>The name of the symbol file is platform dependent. On Windows, the file extension (Either .exe, .dll or .pdb) is replaced with .sym. On all other platforms, the .sym extension is appended to the full file name including potential extensions.</p> <p>Casing rules are mixed:</p> <ul> <li>The file name is as given</li> <li>The signature part of the id (first 32 characters) are uppercase</li> <li>The age part of the id (remaining characters) are lowercase</li> </ul> <p>Schema: <code>&lt;debug_name&gt;/&lt;breakpad-id&gt;/&lt;sym_name&gt;</code></p> <p>The following layout types support this lookup:</p> <ul> <li><code>native</code></li> <li><code>symstore</code></li> <li><code>symstore_index2</code></li> <li><code>ssqp</code></li> </ul>"},{"location":"advanced/symbol-server-compatibility/#microsoft-symbol-server","title":"Microsoft Symbol Server","text":"<p>The public symbol server provided by Microsoft used to only host PDBs for the Windows platform. These use a signature-age debug identifier in addition to the file name to locate symbols. For .NET, this specification was amended by a schema for ELF and MachO-symbols, which is specified as SSQP Key Conventions. This means all non windows platforms are following SSQP rules except for casing.</p> <p>Casing rules for Symbol Server are mixed:</p> <ul> <li>Filenames are as given</li> <li>Identifiers are generally lowercase, except:</li> <li>The signature and age of a PDB identifier is uppercase.</li> <li>The timestamp of a PE identifier is uppercase except the size is   lowercase</li> </ul> <p>Schema:</p> <ul> <li>PE: <code>&lt;code_name&gt;/&lt;Timestamp&gt;&lt;SizeOfImage&gt;/&lt;code_name&gt;</code></li> <li>PDB: <code>&lt;debug_name&gt;/&lt;Signature&gt;&lt;Age&gt;/&lt;debug_name&gt;</code></li> <li>Portable PDB: <code>&lt;debug_name&gt;/&lt;Signature&gt;FFFFFFFF/&lt;debug_name&gt;</code></li> <li>ELF (binary, potentially stripped):   <code>&lt;code_name&gt;/elf-buildid-&lt;note_byte_sequence&gt;/&lt;code_name&gt;</code></li> <li>ELF (debug info): <code>_.debug/elf-buildid-sym-&lt;note_byte_sequence&gt;/_.debug</code></li> <li>MachO (binary): <code>&lt;code_name&gt;/mach-uuid-&lt;uuid_bytes&gt;/&lt;code_name&gt;</code></li> <li>MachO (dSYM): <code>_.dwarf/mach-uuid-sym-&lt;uuid_bytes&gt;/_.dwarf</code></li> </ul> <p>The presence of a <code>index2.txt</code> in the root indicates two tier structure where the first two characters are prepended to the path as an additional folder. So <code>foo.exe/542D5742000f2000/foo.exe</code> is stored as <code>fo/foo.exe/542D5742000f2000/foo.exe</code>. Note that symbolicator does not probe for the <code>index2.txt</code> file. You need to be explicit in configuring it.</p> <p>Source bundles are only supported for PE/PDB files with the following format:</p> <ul> <li>Source bundle: <code>&lt;debug_name&gt;/&lt;Signature&gt;&lt;Age&gt;/&lt;debug_name&gt;.src.zip</code></li> </ul> <p>The following layout types support this lookup:</p> <ul> <li><code>symstore</code> for a regular symbol server</li> <li><code>symstore_index2</code> for a symbol server with an <code>index2.txt</code> root.</li> </ul>"},{"location":"advanced/symbol-server-compatibility/#microsoft-ssqp-symbol-server","title":"Microsoft SSQP Symbol Server","text":"<p>Casing rules for SSQP are mixed:</p> <ul> <li>Filenames are lowercased</li> <li>Identifiers are generally lowercase, except:</li> <li> <p>The age of a PDB identifier is uppercase.</p> </li> <li> <p>PE: <code>&lt;code_name&gt;/&lt;Timestamp&gt;&lt;SizeOfImage&gt;/&lt;code_name&gt;</code></p> </li> <li>PDB: <code>&lt;debug_name&gt;/&lt;Signature&gt;&lt;Age&gt;/&lt;debug_name&gt;</code></li> <li>Portable PDB: <code>&lt;debug_name&gt;/&lt;Signature&gt;FFFFFFFF/&lt;debug_name&gt;</code></li> <li>ELF (binary, potentially stripped):   <code>&lt;code_name&gt;/elf-buildid-&lt;note_byte_sequence&gt;/&lt;code_name&gt;</code></li> <li>ELF (debug info): <code>_.debug/elf-buildid-sym-&lt;note_byte_sequence&gt;/_.debug</code></li> <li>MachO (binary): <code>&lt;code_name&gt;/mach-uuid-&lt;uuid_bytes&gt;/&lt;code_name&gt;</code></li> <li>MachO (dSYM): <code>_.dwarf/mach-uuid-sym-&lt;uuid_bytes&gt;/_.dwarf</code></li> </ul> <p>Additionally, SSQP supports a lookup by SHA1 checksum over the file contents, commonly used for source file lookups. This is not supported.</p> <p>Symbol bundles are only supported for PE/PDB files with the following format:</p> <ul> <li>Source bundle: <code>&lt;debug_name&gt;/&lt;Signature&gt;&lt;Age&gt;/&lt;debug_name&gt;.src.zip</code></li> </ul> <p>The following layout types support this lookup:</p> <ul> <li><code>ssqp</code></li> </ul>"},{"location":"advanced/symbol-server-compatibility/#nuget","title":"Nuget","text":"<p>See \"Microsoft Symbol Server\" for casing rules.</p> <p>Nuget only supports Portable PDB files. Downloading them also requires the file's debug checksum to be supplied via the <code>SymbolChecksum</code> header; see https://github.com/getsentry/rfcs/blob/main/text/0013-portable-pdb.md#nuget-symbol-server-lookups.</p> <ul> <li>Portable PDB: <code>&lt;debug_name&gt;/&lt;Signature&gt;FFFFFFFF/&lt;debug_name&gt;</code></li> </ul>"},{"location":"advanced/symbol-server-compatibility/#lldb-debugger-macos","title":"LLDB Debugger (macOS)","text":"<p>The LLDB debugger on macOS can read debug symbols from File Mapped UUID Directories (scroll down to the second last section). The UUID is broken up by splitting the first 20 hex digits into 4 character chunks, and a directory is created for each chunk. In the final directory, LLDB usually expects a symlink named by the last 12 hex digits, which it follows to the actual dSYM file.</p> <p>Note: this is not actually an LLVM feature. This is in fact a feature of <code>CoreFoundation</code> and exclusively implemented on macOS on top of spotlight. Spotlight indexes these paths and the private <code>DBGCopyFullDSYMURLForUUID</code> API is used by lldb to locate the symbols. macOS uses the symlinks of those locations.</p> <p>Since the executable or library shares the same UUID as the dSYM file, the former are distinguished with a <code>.app</code> suffix.</p> <p>The hex digits are uppercase, the app suffix is lowercase.</p> <ul> <li>MachO (binary): <code>XXXX/XXXX/XXXX/XXXX/XXXX/XXXXXXXXXXXX.app</code></li> <li>MachO (dSYM): <code>XXXX/XXXX/XXXX/XXXX/XXXX/XXXXXXXXXXXX</code></li> </ul> <p>Symbol bundles are supported by adding a <code>.src.zip</code> prefix to the dsym:</p> <ul> <li>Source bundle: <code>XXXX/XXXX/XXXX/XXXX/XXXX/XXXXXXXXXXXX.src.zip</code></li> </ul> <p>The following layout types support this lookup:</p> <ul> <li><code>native</code></li> </ul>"},{"location":"advanced/symbol-server-compatibility/#gdb","title":"GDB","text":"<p>GDB supports multiple lookup methods, depending on the way the debug info file is specified. However, not all of these methods are applicable to a symbol server:</p> <ul> <li>Debug Link Method: GDB looks up the name or relative path specified in the   <code>.gnu.debuglink</code> section. This requires the debug file to be in a relative   position to the actual executable, and does not provide any means to   distinguish by a unique identifier.</li> <li>Build ID Method: Assuming that a GNU build ID note or section have been   written to the ELF file, this specifies a unique identifier for the executable   which is also retained in the debug file. This method is applicable to a   symbol server, but only if the Build ID is present.</li> </ul> <p>The GNU build ID is a variable-length binary string, usually consisting of a 20-byte SHA1 hash of the code section (<code>.text</code>). The lookup path is nn/nnnnnnnn.debug, where nn are the first 2 hex characters of the build ID bit string, and nnnnnnnn are the rest of the bit string. To look up executables, the <code>.debug</code> suffix is omitted.</p> <p>The build-id hex representation is always provided in lowercase.</p> <ul> <li>ELF (binary, potentially stripped)</li> <li>ELF (debug info)</li> <li>WASM (debug info)</li> </ul> <p>Symbol bundles are supported by adding a <code>.src.zip</code> prefix to the ELF:</p> <ul> <li>Source bundle: <code>nn/nnnnnnnn.src.zip</code></li> </ul> <p>The following layout types support this lookup:</p> <ul> <li><code>native</code></li> </ul>"},{"location":"advanced/symbol-server-compatibility/#debuginfod","title":"debuginfod","text":"<p>Symbolicator also supports talking to debuginfod compatible servers for ELF.</p> <p>Schema:</p> <ul> <li>ELF (binary, potentially stripped): <code>&lt;code_note_byte_sequence&gt;/executable</code></li> <li>ELF (debug info): <code>&lt;code_note_byte_sequence&gt;/debuginfo</code></li> </ul> <p>Source bundles are not supported.</p> <p>The following layout types support this lookup:</p> <ul> <li><code>debuginfod</code></li> </ul>"},{"location":"advanced/symbol-server-compatibility/#unified-symbol-server-layout","title":"Unified Symbol Server Layout","text":"<p>If you have no requirements to be compatible with another system you can also use the \"unified\" directory layout structure. This has the advantage that it's unified across all platforms and thus easier to manage. It can store breakpad files, PDBs, PEs and everything else. The <code>symsorter</code> tool in the symbolicator repository can automatically sort debug symbols into this format and also automatically create source bundles.</p> <p>Schema:</p> <p>The debug id is in all cases lowercase in hex format and computed as follows:</p> <ul> <li>PE: <code>&lt;Signature&gt;&lt;Age&gt;</code> (age in hex, not padded)</li> <li>PDB: <code>&lt;Signature&gt;&lt;Age&gt;</code> (age in hex, not padded)</li> <li>Portable PDB: <code>&lt;Signature&gt;&lt;Age&gt;</code> (age in hex, not padded)</li> <li>ELF: <code>&lt;code_note_byte_sequence&gt;</code></li> <li>MachO: <code>&lt;uuid_bytes&gt;</code></li> <li>WASM: <code>&lt;BuildId&gt;</code></li> </ul> <p>The path format is then as follows:</p> <ul> <li>binary: <code>&lt;DebugIdFirstTwo&gt;/&lt;DebugIdRest&gt;/executable</code></li> <li>debug info: <code>&lt;DebugIdFirstTwo&gt;/&lt;DebugIdRest&gt;/debuginfo</code></li> <li>breakpad: <code>&lt;DebugIdFirstTwo&gt;/&lt;DebugIdRest&gt;/breakpad</code></li> <li>source bundle: <code>&lt;DebugIdFirstTwo&gt;/&lt;DebugIdRest&gt;/sourcebundle</code></li> </ul> <p>The following layout types support this lookup:</p> <ul> <li><code>unified</code></li> </ul>"},{"location":"advanced/symbol-server-compatibility/#other-servers","title":"Other Servers","text":"<p>The following additional sources were considered but are not implemented right now:</p>"},{"location":"advanced/symbol-server-compatibility/#fedora-darkserver","title":"Fedora Darkserver","text":"<p>In 2010, Fedora launched a project called \"Darkserver\" that aimed to provide a symbol server for various libraries. In 2012, it seemed to have contained symbols for Debian and Ubuntu as well.</p> <p>However, this projects seems to have been abandoned since and there is only little information available. For now, there is no intention to support Darkserver.</p>"},{"location":"advanced/symbol-server-compatibility/#mozilla-tecken","title":"Mozilla Tecken","text":"<p>Tecken is the symbol server implementation used at Mozilla. The symbol file paths are compatible to Google's Breakpad symbol server. An example of available symbols can be viewed at symbols.mozilla.org.</p> <p>Tecken internally implements a client for the Microsoft Symbol Server to forward downloads for missing symbols. While doing that, it attempts to replace the last character in the URL with an underscore to look up compressed symbols. In any case Tecken tries both variants. Example: <code>foo.exe/&lt;id&gt;/foo.ex_</code>. Microsoft Symbol Server no longer supports this.</p>"},{"location":"advanced/system-architecture/","title":"System Architecture","text":"<p>This page describes the internal structure and processes of Symbolicator.</p>"},{"location":"advanced/system-architecture/#looking-up-debugunwind-information","title":"Looking up debug/unwind information","text":"<p>When finding an object file for a image in a symbolication request, we do the following:</p> <ol> <li>We generate all possible file downloads for each source, based on platform    information and source filters. See Symbol Lookup.</li> <li>We download all files we can get and cache them keyed by source ID and    filepath (<code>ObjectFile</code>).</li> <li>Then we rank all downloaded files:<ol> <li>Objects with debug or unwind information (depending on what we want to use    the object for) are ranked at the top.</li> <li>Objects with a symbol table are ranked second.</li> <li>Unparseable objects are ranked somewhere at the bottom together with empty    files, 404s etc.</li> </ol> </li> <li>Then we generate a symcache or cficache from the best file, save it also    keyed by source ID and filepath. In the cache dir, a symcache file now    basically has the same filename as an object file, just in a different    folder.</li> </ol>"},{"location":"advanced/system-architecture/#objectmeta","title":"<code>ObjectMeta</code>","text":"<p>The issue with the above setup is that one would have to have all objects permanently persisted on disk to be able to decide which symcache to use, which is only feasible in a world with infinite disk space.</p> <p>For this purpose we have the concept of an <code>ObjectMeta</code> cache, which stores information about the quality of an <code>ObjectFile</code> and is persisted for much longer. <code>ObjectFile</code>s are deleted just a few days after download while <code>ObjectMeta</code>s stick around for as long as the symcache/cficache does.</p>"},{"location":"advanced/system-architecture/#the-object-cache-key","title":"The object cache key","text":"<p>As mentioned earlier, <code>ObjectFile</code>s, symcaches/cficaches (and <code>ObjectMeta</code>s) are cached by source ID and filepath. What this actually means depends on the source type:</p> <ul> <li>For the HTTP source type (Microsoft SymStore etc) this is just the source ID   as given in the symbolication request + the filepath of the download URL.</li> <li>For S3 and GCS buckets this is the source ID and the object key/path (object   as in S3 object).</li> <li>For the Sentry source type this is the source ID and the numeric \"Debug File   Id\".</li> </ul> <p>In summary, the cache key is just whatever is necessary to uniquely identify a file within a source.</p>"},{"location":"advanced/system-architecture/#generating-all-possible-file-downloads-for-a-source","title":"Generating all possible file downloads for a source","text":"<p>In step 1, we mentioned that we generate all possible file downloads. For most filesystem-like source types this is a simple computation that takes an <code>ObjectId</code> (really a quintuple of debug and code ID + debug name + code name) and generates possible filepaths. The logic for this lives in <code>src/utils/paths.rs</code>.</p> <p>For the Sentry source type, this looks a bit different. Since Sentry already builds some sort of index based on debug and code ID, we first have to issue an HTTP request to Sentry to search for files based on those IDs. We get back a list of numeric \"Debug File Ids\" (those are just the integer PK in Postgres) that we then can download one by one.</p> <p>Since this step is quite expensive for Sentry, it is cached separately. This part is currently WIP.</p>"},{"location":"advanced/system-architecture/#example","title":"Example","text":"<p>The logic for looking up debug information for an image looks as follows (simplified, conflating code_name vs debug_name + code_id vs debug_id):</p> <ul> <li>Lookup of object <code>name=wkernel32.pdb, id=0xdeadbeef</code> (uncached, parallelized):<ul> <li>(cached) Fetching sentry index for <code>id=0xdeadbeef</code> (uncached) -&gt; returns   <code>[123456]</code></li> <li>(cached) lookup of object metadata <code>[sentry, 123456]</code> -&gt; returns   <code>has_debug_info=true, ...</code><ul> <li>(cached) lookup of object file <code>[sentry, 123456]</code></li> </ul> </li> <li>(cached) lookup of object metadata <code>[microsoft,   /wkernel32.pdb/deadbeef/wkernel32.pdb]</code> -&gt; returns <code>has_debug_info=false,   ...</code><ul> <li>(cached) lookup of object file <code>[microsoft,   /wkernel32.pdb/deadbeef/wkernel32.pdb]</code></li> </ul> </li> <li>Sentry project symbol wins, because it has more than symbol table</li> </ul> </li> <li>(cached) lookup of symcache <code>[sentry, 123456]</code></li> </ul> <p>All steps that are behind a caching layer are prefixed with <code>(cached)</code>. If a cache hit occurs, the sub-bulletpoints are not executed.</p>"},{"location":"api/","title":"API","text":"<p>Symbolicator exposes a HTTP API to allow symbolication of raw native stack traces, minidumps, and JavaScript stack traces. All information necessary for symbolication needs to be part of the request, such as external buckets and their auth tokens or full stack traces. There are the following endpoints:</p> <ul> <li><code>POST /symbolicate</code>: Symbolicate raw native stacktrace</li> <li><code>POST /minidump</code>: Symbolicate a minidump and extract information</li> <li><code>POST /applecrashreport</code>: Symbolicate an Apple Crash Report</li> <li><code>POST /symbolicate-js</code>: Symbolicate JavaScript stacktrace</li> <li><code>POST /symbolicate-jvm</code>: Symbolicate JVM stacktrace</li> <li><code>GET /requests/:id</code>: Status update on running symbolication jobs</li> <li><code>GET /healthcheck</code>: System status and health monitoring</li> </ul>"},{"location":"api/#sources","title":"Sources","text":"<p>For Symbolicator to operate correctly, it needs to be pointed to at least one source. It supports various different backends for where it looks for symbols. There are two modes for Symbolicator with regards to how it looks for symbols. One is the preconfigured mode where the <code>sources</code> key is configured right in the config file. The second is one where the sources are defined with the HTTP request to the symbolication API.</p> <p>If you want to use Symbolicator as a symstore compatible proxy you need to preconfigure the sources.</p> <p>Example configuration:</p> <pre><code>[\n  {\n    \"id\": \"my-bucket-linux\",\n    \"type\": \"s3\",\n    \"bucket\": \"my-project-my-bucket\",\n    \"region\": \"us-east-1\",\n    \"prefix\": \"/linux\",\n    \"access_key\": \"AMVSAVWEXRIRJPOMCKWN\",\n    \"secret_key\": \"Lqnc45YWr9y7qftCI+vST/1ZPmmw1H6SkbIf2v/8\",\n    \"filters\": {\n      \"filetypes\": [\"elf_debug\", \"elf_code\"]\n    },\n    \"layout\": {\n      \"type\": \"native\",\n      \"casing\": \"lowercase\"\n    }\n  },\n  {\n    \"id\": \"my-bucket-windows\",\n    \"type\": \"s3\",\n    \"bucket\": \"my-project-my-bucket\",\n    \"region\": \"us-east-1\",\n    \"prefix\": \"/windows\",\n    \"access_key\": \"AMVSAVWEXRIRJPOMCKWN\",\n    \"secret_key\": \"Lqnc45YWr9y7qftCI+vST/1ZPmmw1H6SkbIf2v/8\",\n    \"filters\": {\n      \"filetypes\": [\"pe\", \"pdb\"]\n    },\n    \"layout\": {\n      \"type\": \"native\",\n      \"casing\": \"lowercase\"\n    }\n  },\n  {\n    \"id\": \"microsoft\",\n    \"type\": \"http\",\n    \"filters\": {\n      \"filetypes\": [\"pe\", \"pdb\"]\n    },\n    \"url\": \"https://msdl.microsoft.com/download/symbols/\"\n  }\n]\n</code></pre> <p>Sources are ordered by priority. Each source needs at least two keys:</p> <ul> <li><code>id</code>: the ID of the source. This can be freely chosen and is used to identify   cache files in the cache folder</li> <li><code>type</code>: defines the type of the source (<code>http</code>, <code>s3</code>, <code>gcs</code> or <code>sentry</code>)</li> </ul> <p>These are common parameters that work on most symbol sources (except <code>sentry</code>):</p> <ul> <li> <p><code>filters</code>: a set of filters to reduce the number of unnecessary hits on a   symbol server. This configuration key is an object with two keys:</p> <ul> <li><code>filetypes</code>: a list of file types to restrict the server to. Possible   values: <code>pe</code>, <code>pdb</code>, <code>mach_debug</code>, <code>mach_code</code>, <code>elf_debug</code>, <code>elf_code</code>,   <code>breakpad</code>)</li> <li><code>path_patterns</code>: a list of glob matches that need to be matched on the image   name. If the debug image has no name it will never match here.</li> </ul> </li> <li> <p><code>layout</code>: configures the file system layout of the sources. This configuration   key is an object with two keys:</p> <ul> <li><code>type</code>: defines the general layout of the directory. Possible values are   <code>native</code>, <code>symstore</code>, <code>symstore_index2</code>, <code>ssqp</code>, and <code>unified</code>.   <code>native</code> uses the file type's native format. <code>symstore</code> and <code>ssqp</code> both   use the Microsoft Symbol Server format but control the case   conventions. <code>symstore</code> uses the conventional casing rules for   signatures and filenames, <code>ssqp</code> uses the Microsoft SSQP casing rules   instead. Additionally <code>symstore_index2</code> works like <code>symstore</code> but uses   the \"Two tier\" (index2.txt) layout where the first two characters of   the filename are used as a toplevel extra folder. <code>unified</code> is the   unified lookup format that symbolicator recommends.</li> <li><code>casing</code>: enforces a casing style. The default is not to touch the casing   and forward it unchanged. If the backend does not support a case insensitive   backend (eg: S3) then it's recommended to set this to <code>lowercase</code> to enforce   changing all to lowercase. Possible values: <code>default</code>, <code>lowercase</code>,   <code>uppercase</code>.</li> </ul> </li> </ul>"},{"location":"api/#http-source","title":"HTTP source","text":"<p>The HTTP source lets one fetch symbols from a Microsoft Symbol Server or similar systems. There is some flexibility to how it operates.</p> <ul> <li><code>type</code>: <code>\"http\"</code></li> <li><code>url</code>: This defines the URL where symbolicator should be fetching from. For   instance this can be <code>https://msdl.microsoft.com/download/symbols/</code> to point   it to the official microsoft symbol server.</li> <li><code>headers</code>: an optional dictionary of headers that should be sent with the HTTP   requests. This can be used for instance to configure HTTP basic auth   configuration.</li> </ul>"},{"location":"api/#amazon-s3-bucket","title":"Amazon S3 Bucket","text":"<p>This source connects straight to an S3 bucket and looks for symbols there. It's recommended for this to be configured with explicit <code>lowercase</code> casing to avoid issues as the SSQP protocol demands case insensitive lookups.</p> <ul> <li><code>type</code>: <code>\"s3\"</code></li> <li><code>bucket</code>: the name of the S3 bucket</li> <li><code>prefix</code>: a path prefix to put in front of all keys (eg: <code>/windows</code>)</li> <li><code>region</code>: the AWS region where the bucket is located. Default regions can be   supplied as strings, i.e. \"us-east-1\". In order to use a custom region for an   S3 compatible service such as Ceph or minio, specify a tuple:   <code>[\"custom-region-name\", \"http://minio-address/\"]</code>.</li> <li><code>access_key</code>: the AWS access key to use</li> <li><code>secret_key</code>: the AWS secret key to use</li> </ul>"},{"location":"api/#gcs-bucket","title":"GCS Bucket","text":"<p>This source connects to a GCS bucket and looks for symbols there. It behaves similarly to <code>s3</code> but uses different credentials:</p> <ul> <li><code>type</code>: <code>\"gcs\"</code></li> <li><code>bucket</code>: the name of the GCS bucket</li> <li><code>prefix</code>: a path prefix to put in front of all keys (eg: <code>/windows</code>)</li> <li><code>private_key</code>: the GCS private key (base64 encoded and with optional PEM   envelope)</li> <li><code>client_email</code>: the GCS client email for authentication</li> </ul>"},{"location":"api/#sentry","title":"Sentry","text":"<p>This points Symbolicator at a Sentry installation to fetch customer supplied symbols from there. Sentry applies proper configuration automatically.</p>"},{"location":"api/applecrashreport/","title":"Apple Crash Report","text":"<pre><code>POST /applecrashreport?timeout=5&amp;scope=123 HTTP/1.1\nContent-Type: multipart/form-data; boundary=xxx\n\n--xxx\nContent-Disposition: form-data; name=\"apple_crash_report\"\n\n[text file contents]\n--xxx\nContent-Disposition: form-data; name=\"sources\"\nContent-Type: application/json\n\n[\n  {\n    \"id\": \"&lt;uuid&gt;\",\n    \"type\": \"http\",\n    ... // see \"Sources\"\n  },\n  ...\n]\n\n--xxx\nContent-Disposition: form-data; name=\"platform\"\n\"native\"\n\n--xxx--\n</code></pre>"},{"location":"api/applecrashreport/#query-parameters","title":"Query Parameters","text":"<ul> <li><code>timeout</code>: If given, a response status of <code>pending</code> might be sent by the   server.</li> <li><code>scope</code>: An optional scope which will be used to isolate cached files from   each other</li> </ul>"},{"location":"api/applecrashreport/#request-body","title":"Request Body","text":"<p>A multipart form data body containing the minidump, as well as the external sources to pull symbols from.</p> <ul> <li><code>platform</code>: The event' platform.</li> <li><code>sources</code>: A list of descriptors for internal or external symbol sources. See   Sources.</li> <li><code>upload_file_minidump</code>: The minidump file to be analyzed.</li> </ul>"},{"location":"api/applecrashreport/#response","title":"Response","text":"<p>See Symbolication Response.</p>"},{"location":"api/minidump/","title":"Minidump Request","text":"<pre><code>POST /minidump?timeout=5&amp;scope=123 HTTP/1.1\nContent-Type: multipart/form-data; boundary=xxx\n\n--xxx\nContent-Disposition: form-data; name=\"upload_file_minidump\"\n[binary blob]\n\n--xxx\nContent-Disposition: form-data; name=\"sources\"\n[\n  {\n    \"id\": \"&lt;uuid&gt;\",\n    \"type\": \"http\",\n    ... // see \"Sources\"\n  },\n  ...\n]\n\n--xxx\nContent-Disposition: form-data; name=\"platform\"\n\"native\"\n\n--xxx--\n</code></pre>"},{"location":"api/minidump/#query-parameters","title":"Query Parameters","text":"<ul> <li><code>timeout</code>: If given, a response status of <code>pending</code> might be sent by the   server.</li> <li><code>scope</code>: An optional scope which will be used to isolate cached files from   each other</li> </ul>"},{"location":"api/minidump/#request-body","title":"Request Body","text":"<p>A multipart form data body containing the minidump, as well as the external sources to pull symbols from.</p> <ul> <li><code>platform</code>: The event' platform.</li> <li><code>sources</code>: A list of descriptors for internal or external symbol sources. See   Sources.</li> <li><code>upload_file_minidump</code>: The minidump file to be analyzed.</li> </ul>"},{"location":"api/minidump/#response","title":"Response","text":"<p>See Symbolication Response.</p>"},{"location":"api/proxy/","title":"Symbol Server Proxy","text":"<p>If the symstore proxy is enabled, Symbolicator also acts as a symbol proxy. This means that all configured sources are probed for symbol queries below the <code>/proxy</code> prefix. The path following this prefix needs to be a valid SSQP query.</p> <p>Example:</p> <pre><code>$ curl -IL http://localhost:3021/proxy/wkernel32.pdb/ff9f9f7841db88f0cdeda9e1e9bff3b51/wkernel32.pdb\nHTTP/1.1 200 OK\ncontent-length: 846848\ncontent-type: application/octet-stream\ndate: Fri, 19 Apr 2019 22:47:54 GMT\n</code></pre> <p>The layout of a configured source can limit what kind of queries to it will succeed. For example, SSQP supports querying for a PE file with timestamp and file size, but the \"unified\" source layout requires executables to be sorted by their debug IDs. This means that such a query will not find the file on a \"unified\" source. For best results, use the \"symstore\" layout for sources that you plan to proxy via Symbolicator.</p> <p>When fetching ELF or MachO symbols the filename can be largely omitted (non extension can be substituted with an underscore) when a configured backend uses the \"native\" directory format. In simple terms this means that <code>/symbols/_/elf-buildid-180a373d6afbabf0eb1f09be1bc45bd796a71085/_</code> is a valid query for an ELF executable and <code>/symbols/_.debug/elf-buildid-sym-180a373d6afbabf0eb1f09be1bc45bd796a71085/_.debug</code> is a valid query for an ELF debug symbol.</p>"},{"location":"api/response/","title":"Symbolication Response","text":""},{"location":"api/response/#native-response","title":"Native Response","text":"<p>The response to a native symbolication request is a JSON object which contains different data depending on the status of the symbolication job:</p> <ul> <li><code>pending</code>: Symbolication has not finished yet; try again later. This is only   returned after the timeout has expired, if one was specified.</li> <li><code>complete</code>: The symbolication request has been processed and results are   ready. This status is only reported once, after which the job is cleaned up.</li> <li><code>error</code>: Something went wrong during symbolication, and details are in the   payload.</li> </ul>"},{"location":"api/response/#success-response","title":"Success Response","text":"<p>Symbol server responds with 200 OK and the response payload listed below if symbolication succeeds within a configured timeframe (around 20 seconds):</p> <pre><code>{\n  \"status\": \"complete\",\n\n  // Symbolicated stack traces\n  \"stacktraces\": [\n    {\n      \"frames\": [\n        {\n          // Symbolication meta data\n          \"status\": \"symbolicated\",\n          \"original_index\": 0,\n\n          // Frame information\n          \"instruction_addr\": \"0xfeedbeef\",  // actual address of the frame\n          \"addr_mode\": \"abs\",                // address mode\n          \"sym_addr\": \"0xfeed0000\",          // start address of the function\n          \"package\": \"/path/to/module.so\",   // path to the module's code file\n          \"symbol\": \"__1cGmemset6FpviI_0_\",  // original mangled function name\n          \"function\": \"memset\",              // demangled short version of symbol\n          \"lang\": \"cpp\",\n          \"abs_path\": \"/path/to/src/file.c\", // normalized absolute path\n          \"filename\": \"../src/file.c\",       // path relative to compilation dir\n          \"lineno\": 22,\n        },\n        ...\n      ],\n      \"registers\": { ... }\n    }\n  ],\n\n  // Modules completed with information read from object files\n  \"modules\": [\n    {\n      \"status\": \"found\",\n      ...\n    }\n  ],\n  // Additional information read from crash report\n  \"arch\": \"x86_64\",\n  \"signal\": 11,\n  \"os\": {\n    \"name\": \"Windows NT\",\n    \"version\": \"8.1.2700\"\n  }\n}\n</code></pre> <p>The symbolicated frames are returned in the same order as provided in the request. Additional properties passed in the request are discarded. Errors that occurred during symbolication, such as missing symbol files or unresolvable addresses within symbols are reported as values for <code>status</code> in both modules and frames.</p>"},{"location":"api/response/#note-on-addresses","title":"Note on Addresses","text":"<p>Addresses (<code>instruction_addr</code> and <code>sym_addr</code>) can come in two versions. They can be absolute or relative. Symbolicator will always try to make addresses absolute but in some cases this cannot be done. For instance WASM modules do not have absolute addresses in which case the addresses stay relative. This is identified by the <code>addr_mode</code> property. When it's set to <code>\"abs\"</code> it means the addresses are absolute, when <code>\"rel:X\"</code> it's relative to module index <code>X</code>.</p>"},{"location":"api/response/#backoff-response","title":"Backoff Response","text":"<p>If symbolication takes longer than the threshold <code>timeout</code>, the server instead responds with a backoff response. It will then continue to fetch symbols and symbolication. The response indicates the estimated time for symbol retrieval, after which the symbolication request can be expected to succeed:</p> <pre><code>{\n  \"status\": \"pending\",\n  \"request_id\": \"deadbeef\",\n  \"retry_after\": 300 // 5 minutes\n}\n</code></pre> <p>The symbolication server must not send a backoff response if no timeout was sent by the client.</p> <p>Note that the <code>retry_after</code> value is just an estimation and does not give any guarantee. The request may be repeated at any time:</p> <pre><code>GET /requests/deadbeef?timeout=123\n</code></pre>"},{"location":"api/response/#invalid-request-response","title":"Invalid Request Response","text":"<p>If the user provided a non-existent request ID, the server responds with 404 Not Found.</p> <p>Requests should always be treated transient as they might disappear during a deploy. Clients must expect that 404 is returned even for valid request IDs and then re-schedule symbolication</p> <p>On a related note, state on the server is generally ephemeral.</p>"},{"location":"api/response/#javascript-response","title":"JavaScript Response","text":"<p>The response to a JavaScript symbolication request is a JSON object which contains a list of original raw stack traces, corresponding list of processed stack traces and an optional list of errors that happened during symbolication.</p> <pre><code>{\n  \"stacktraces\": [\n    {\n      \"frames\": [\n        {\n          \"function\": \"onFailure\",\n          \"filename\": \"test.js\",\n          \"module\": \"files/test\",\n          \"abs_path\": \"http://localhost:&lt;port&gt;/files/test.js\",\n          \"lineno\": 5,\n          \"colno\": 11,\n          \"pre_context\": [\n            \"var makeAFailure = (function() {\",\n            \"  function onSuccess(data) {}\",\n            \"\",\n            \"  function onFailure(data) {\"\n          ],\n          \"context_line\": \"    throw new Error('failed!');\",\n          \"post_context\": [\n            \"  }\",\n            \"\",\n            \"  function invoke(data) {\",\n            \"    var cb = null;\",\n            \"    if (data.failed) {\"\n          ],\n          \"data\": {\n            \"sourcemap\": \"http://localhost:&lt;port&gt;/files/app.js.map\"\n          }\n        }\n      ]\n    }\n  ],\n  \"raw_stacktraces\": [\n    {\n      \"frames\": [\n        {\n          \"abs_path\": \"http://localhost:&lt;port&gt;/files/app.js\",\n          \"lineno\": 1,\n          \"colno\": 64,\n          \"context_line\": \"var makeAFailure=function(){function n(n){}function e(n){throw new Error(\\\"failed!\\\")}function r(r){var i=null;if(r.failed){i=e}else{i=n}i(r)} {snip}\",\n          \"post_context\": [\n            \"\",\n            \"\",\n            \"//# sourceMappingURL=a.different.map\",\n            \"\",\n            \"//@ sourceMappingURL=another.different.map\"\n          ]\n        }\n      ]\n    }\n  ],\n  \"errors\": [\n    {\n      \"abs_path\": \"http://localhost:&lt;port&gt;/assets/missing_bar.js\",\n      \"type\": \"missing_source\"\n    }\n  ]\n}\n</code></pre>"},{"location":"api/response/#jvm-response","title":"JVM Response","text":"<p>The response to a JVM symbolication request is a JSON object which contains a list of processed stack traces, exceptions and classes as well as an optional list of error that happen during symbolication.</p> <pre><code>{\n  \"exceptions\": [\n    {\n      \"type\": \"RuntimeException\",\n      \"module\": \"java.lang\"\n    }\n  ],\n  \"stacktraces\": [\n    {\n      \"frames\": [\n        {\n          \"function\": \"onMenuItemClick\",\n          \"filename\": \"EditActivity\",\n          \"module\": \"io.sentry.samples.instrumentation.ui.EditActivity$$InternalSyntheticLambda$1$ebaa538726b99bb77e0f5e7c86443911af17d6e5be2b8771952ae0caa4ff2ac7$0\",\n          \"abs_path\": \"EditActivity\",\n          \"lineno\": 0,\n          \"in_app\": true,\n          \"index\": 18\n        },\n        {\n          \"function\": \"onCreate$lambda-1\",\n          \"module\": \"io.sentry.samples.instrumentation.ui.EditActivity\",\n          \"lineno\": 37,\n          \"pre_context\": [\n            \"        }\",\n            \"\",\n            \"        findViewById&lt;Toolbar&gt;(R.id.toolbar).setOnMenuItemClickListener {\",\n            \"            if (it.itemId == R.id.action_save) {\",\n            \"                try {\"\n          ],\n          \"context_line\": \"                    SomeService().helloThere()\",\n          \"post_context\": [\n            \"                } catch (e: Exception) {\",\n            \"                    Sentry.captureException(e)\",\n            \"                }\",\n            \"\",\n            \"                val transaction = Sentry.startTransaction(\"\n          ],\n          \"in_app\": true,\n          \"index\": 18\n        }\n      ]\n    }\n  ],\n  \"classes\": {},\n  \"errors\": [\n    {\n      \"uuid\": \"8236f5cf-52c8-4e35-a7cf-01421e4c2c88\",\n      \"type\": \"missing\"\n    }\n  ]\n}\n</code></pre>"},{"location":"api/sourcemaps/","title":"Symbolication Request","text":"<pre><code>POST /symbolicate-js?timeout=123&amp;scope=123 HTTP/1.1\nContent-Type: application/json\n\n{\n  \"platform\": \"node\",\n  \"source\": {\n    \"id\": \"&lt;id&gt;\",\n    \"url\": \"https://sentry.io/api/0/projects/sentry-org/sentry-project/artifact-lookup/\",\n    \"token\": \"secret\"\n  },\n  \"stacktraces\": [\n    {\n      \"frames\": [\n        {\n          \"function\": \"x\",\n          \"module\": \"x\",\n          \"filename\": \"x\",\n          \"abs_path\": \"x\",\n          \"lineno\": 1,\n          \"colno\": 1,\n          \"in_app\": true\n        }\n      ]\n    }\n  ],\n  \"modules\": [\n    {\n      \"code_file\": \"some-code-file\",\n      \"debug_id\": \"some-debug-id\",\n      \"type\": \"debug_id\"\n    }\n  ],\n  \"dist\": \"production\",\n  \"release\": \"1.33.1\",\n  \"scraping\": {\n    \"enabled\": true,\n    \"allowed_origins\": [\"*.domain.com\"]\n  }\n}\n</code></pre>"},{"location":"api/sourcemaps/#query-parameters","title":"Query Parameters","text":"<ul> <li><code>timeout</code>: If given, a response status of <code>pending</code> might be sent by the   server.</li> <li><code>scope</code>: An optional scope which will be used to isolate cached files from   each other</li> </ul>"},{"location":"api/sourcemaps/#request-body","title":"Request Body","text":"<p>A JSON payload describing the stack traces and code modules for symbolication, as well as configuration for scraping sources from external servers:</p> <ul> <li><code>platform</code>: The event's platform.</li> <li><code>source</code>: A descriptor for the Sentry source to be used for symbolication. See   Sentry source.</li> <li><code>modules</code>: A list of source code files with a corresponding debug id that   were loaded during JS code execution. The list is handled by the Sentry source.</li> <li><code>stacktrace</code>: A list of stacktraces to symbolicate.</li> <li><code>frames</code>: A list of frames with corresponding <code>abs_path</code>, <code>lineno</code>,     and other optional fields like <code>colno</code> or minified <code>function</code> name.</li> <li><code>release</code>: Name of Sentry <code>release</code> for the processed request.</li> <li><code>dist</code>: Name of Sentry <code>dist</code> for the processed request.</li> <li><code>scraping</code>: Configuration for scraping of JS sources and sourcemaps from the web.</li> <li><code>enabled</code>: Whether scraping should happen at all.</li> <li><code>allowed_origins</code>: A list of \"allowed origin patterns\" that control what     URLs we are allowed to scrape from. Allowed origins may be defined in several ways:<ul> <li><code>http://domain.com[:port]</code>: Exact match for base URI (must include port).</li> <li><code>*</code>: Allow any domain.</li> <li><code>*.domain.com</code>: Matches domain.com and all subdomains, on any port.</li> <li><code>domain.com</code>: Matches domain.com on any port.</li> <li><code>*:port</code>: Wildcard on hostname, but explicit match on port.</li> </ul> </li> <li><code>headers</code>: A map of headers to send with every HTTP request while scraping.</li> <li><code>options</code>: Symbolication-specific options which control the endpoint's behavior.</li> <li><code>apply_source_context</code>: Whether to apply source context for the stack frames.</li> </ul>"},{"location":"api/sourcemaps/#response","title":"Response","text":"<p>See Symbolication Response.</p>"},{"location":"api/symbolicate-jvm/","title":"Symbolication Request","text":"<pre><code>POST /symbolicate-jvm?timeout=123&amp;scope=123 HTTP/1.1\nContent-Type: application/json\n\n{\n    \"platform\": \"java\",\n    \"source\": [\n        {\n            \"type\": \"s3\",\n            \"id\": \"&lt;id&gt;\",\n            \"url\": \"https://sentry.io/api/0/projects/sentry-org/sentry-project/artifact-lookup/\",\n            \"token\": \"secret\"\n        }\n    ],\n    \"exceptions\": [\n        {\n            \"type\": \"RuntimeException\",\n            \"module\": \"io.sentry.samples\"\n        }\n    ],\n    \"stacktraces\": [\n        {\n            \"frames\": [\n                {\n                    \"function\": \"otherMethod\",\n                    \"filename\": \"OtherActivity.java\",\n                    \"module\": \"OtherActivity\",\n                    \"abs_path\": \"OtherActivity.java\",\n                    \"lineno\": 100,\n                    \"index\": 0\n                }\n            ]\n        }\n    ],\n    \"modules\": [\n        {\n            \"type\": \"source\",\n            \"uuid\": \"246fb328-fc4e-406a-87ff-fc35f6149d8f\"\n        },\n        {\n            \"type\": \"proguard\",\n            \"uuid\": \"05d96b1c-1786-477c-8615-d3cf83e027c7\"\n        }\n    ],\n    \"release_package\": \"some_release\",\n    \"classes\": [],\n    \"options\": {\n        \"apply_source_context\": true\n    }\n}\n</code></pre>"},{"location":"api/symbolicate-jvm/#query-parameters","title":"Query Parameters","text":"<ul> <li><code>timeout</code>: If given, a response status of <code>pending</code> might be sent by the   server.</li> <li><code>scope</code>: An optional scope which will be used to isolate cached files from   each other</li> </ul>"},{"location":"api/symbolicate-jvm/#request-body","title":"Request Body","text":"<ul> <li><code>platform</code>: The event's platform.</li> <li><code>source</code>: A descriptor for the Sentry source to be used for symbolication. See   Sentry source. Note that only proguard files uploaded to Sentry are supported at the moment.</li> <li><code>exceptions</code>: A list of exceptions which will have their module and type fields remapped.</li> <li><code>modules</code>: A list of source code files with a corresponding debug id that   were loaded during JVM code execution. The list is handled by the Sentry source.</li> <li><code>stacktrace</code>: A list of stacktraces to symbolicate.</li> <li><code>frames</code>: A list of frames with corresponding <code>abs_path</code>, <code>lineno</code>,     and other optional fields like <code>colno</code> or minified <code>function</code> name.</li> <li><code>release_package</code>: Name of Sentry <code>release</code> for the processed request.</li> <li><code>classes</code>: A list of classes which will have their names remapped and returned in the form of a map. Allows for deobfuscation of view hierarchies.</li> <li><code>options</code>: Symbolication-specific options which control the endpoint's behavior.</li> <li><code>apply_source_context</code>: Whether to apply source context for the stack frames.</li> </ul>"},{"location":"api/symbolicate-jvm/#response","title":"Response","text":"<p>See Symbolication Response.</p>"},{"location":"api/symbolication/","title":"Symbolication Request","text":"<pre><code>POST /symbolicate?timeout=123&amp;scope=123 HTTP/1.1\nContent-Type: application/json\n\n{\n  \"platform\": \"native\",\n  \"signal\": 11,\n  \"sources\": [\n    {\n      \"id\": \"&lt;uuid&gt;\",\n      \"type\": \"http\",\n      ...\n    },\n    ...\n  ],\n  \"threads\": [\n    {\n      \"frames\": [\n        {\n          \"instruction_addr\": \"0xfeedbeef\",\n          \"addr_mode\": \"rel:0\"\n        },\n        ...\n      ],\n      \"registers\": {\n        \"rip\": \"0xfeedbeef\",\n        \"rsp\": \"0xfeedface\"\n      }\n    }\n  ],\n  \"modules\": [\n    {\n      \"type\": \"macho\",\n      \"debug_id\": \"some-debug-id\",\n      \"code_id\": \"some-debug-id\",\n      \"debug_file\": \"/path/to/image.so\",\n      \"image_addr\": \"0xfeedbeef\",\n      \"image_size\": \"0xbeef\"\n    },\n    ...\n  ]\n}\n</code></pre>"},{"location":"api/symbolication/#query-parameters","title":"Query Parameters","text":"<ul> <li><code>timeout</code>: If given, a response status of <code>pending</code> might be sent by the   server.</li> <li><code>scope</code>: An optional scope which will be used to isolate cached files from   each other</li> </ul>"},{"location":"api/symbolication/#request-body","title":"Request Body","text":"<p>A JSON payload describing the stack traces and code modules for symbolication, as well as external sources to pull symbols from:</p> <ul> <li><code>platform</code>: The event's platform.</li> <li><code>sources</code>: A list of descriptors for internal or external symbol sources. See   Sources.</li> <li><code>modules</code>: A list of code modules (aka debug images) that were loaded into the   process. All attributes other than <code>type</code>, <code>image_addr</code> and <code>image_size</code> are   required. The Symbolicator may optimize lookups based on the <code>type</code> if present.   Valid types are <code>macho</code>, <code>pe</code>, <code>elf</code>. Invalid types are silently ignored. The   Symbolicator still works if the type is invalid, but less efficiently. However,   a schematically valid but wrong type is fatal for finding symbols.</li> <li><code>threads</code>: A list of process threads to symbolicate.</li> <li><code>registers</code>: Optional register values aiding symbolication heuristics. For     example, register values may be used to perform correction heuristics on the     instruction address of the top frame.</li> <li><code>frames</code>: A list of frames with addresses. Arbitrary additional properties     may be passed with frames, but are discarded. The <code>addr_mode</code> property     defines the beahvior of <code>instruction_addr</code>.</li> <li><code>scraping</code>: Configuration for authenticating scraping requests via http headers.</li> <li><code>enabled</code>: Whether authentication should happen at all.</li> <li><code>allowed_origins</code>: A list of \"allowed origin patterns\" that control what     URLs we are authenticating. Allowed origins may be defined in several ways:<ul> <li><code>http://domain.com[:port]</code>: Exact match for base URI (must include port).</li> <li><code>*</code>: Allow any domain.</li> <li><code>*.domain.com</code>: Matches domain.com and all subdomains, on any port.</li> <li><code>domain.com</code>: Matches domain.com on any port.</li> <li><code>*:port</code>: Wildcard on hostname, but explicit match on port.</li> </ul> </li> <li><code>headers</code>: A map of headers to send with every HTTP request while scraping.</li> </ul>"},{"location":"api/symbolication/#response","title":"Response","text":"<p>See Symbolication Response.</p>"}]}